var https = require('https');var fs = require('fs');var ffmpeg = require('fluent-ffmpeg');var http = require("http2");var config = require('./config');var bsplit = require('buffer-split');process.env.NODE_TLS_REJECT_UNAUTHORIZED = "0";var ACCESS_TOKEN = null;var ACCESS_TOKEN_VALID_UNTIL = null;// re-encode the file to a format compatible with AVSif(process.argv[2]) {    console.log("Sending file: " + process.argv[2]);    ffmpeg(process.argv[2]).on('end', function() {        getAccessToken(function(err, access_token) {            if(err) {                console.log("Error during call to LWA: " + err);            } else {                callAlexa(access_token, "file_processed.raw", function(err, content, is_dialog) {                    if(err) {                        console.log("Error during call to alexa: " + err);                    } else if(content) {                        console.log("...Finished alexa call, receiving audio response...");                        var alexa_response = fs.createWriteStream("response.mp3");                        alexa_response.write(content, function() {                            alexa_response.end();                            if(is_dialog) {                                console.log('...Response written to response.mp3.  Prompt is expected...')                            } else {                                console.log('...Response written to response.mp3.')                            }                        });                    } else {                        console.log("...Finished alexa call, received no content.");                        if(is_dialog) {                            console.log('Prompt is expected...')                        } else {                            // do nothing                        }                    }                });            }        });    })        .audioCodec('pcm_s16le')        .audioBitrate('16k')        .format('s16le')        .audioChannels(1)        .audioFrequency(16000)        .save("file_processed.raw");} else {    console.log("Usage: node index.js file.mp3")}function tryDownloadRecording(attempt, filename, recordingUrl, callback) {    if(config.DEBUG) console.log("Download attempt " + attempt + ": " + recordingUrl);    var file = fs.createWriteStream(filename);    https.get(recordingUrl + ".mp3", function(res) {        res.pipe(file);        file.on('finish', function() {            file.close(function() {                var stats = fs.statSync(filename);                if(config.DEBUG) console.log("Wrote file with " + stats["size"] + " bytes.")                if(stats["size"] < 1000) {                    if(config.DEBUG) console.log("Got a file less than 1k bytes (" + stats["size"] + ").");                    if(attempt > 5) {                        callback(new Error("Couldn't download a valid file after " + attempt + " attempts."));                    } else {                        tryDownloadRecording(++attempt, filename, recordingUrl, callback);                    }                } else {                    callback(null, filename);                }            });        });    });}function getAccessToken(callback) {    if(ACCESS_TOKEN && ((new Date()).getTime() < ACCESS_TOKEN_VALID_UNTIL)) {        if(config.DEBUG) console.log("Getting cached token...");        callback(null, ACCESS_TOKEN);    } else {        if(config.DEBUG) console.log("Getting new token...");        // get an access token using the refresh token        var options = {            method: "POST",            hostname: "api.amazon.com",            port: 443,            path: "/auth/o2/token",            headers: {                "content-type": "application/x-www-form-urlencoded;charset=UTF-8"            },            agent: new http.Agent({ keepAlive: false })  // turn off keep alive to avoid EOF errors        }        var req = http.request(options, function(res) {            var chunks = [];            res.on("data", function (chunk) {                chunks.push(chunk);            });            res.on("error", function (err) {                if(config.DEBUG) console.log("Access token response failed, trying again...");                getAccessToken(callback);            });            res.on("end", function () {                // grab the access token                var access_token_response = JSON.parse(Buffer.concat(chunks));                if(config.DEBUG) console.log("Got token: " + JSON.stringify(access_token_response));                ACCESS_TOKEN = access_token_response.access_token;                ACCESS_TOKEN_VALID_UNTIL = (new Date()).getTime() + (access_token_response.expires_in * 1000) - 10000;                callback(null, ACCESS_TOKEN);            });        });        req.on("error", function (err) {            console.log(err);            if (config.DEBUG) console.log("Access token request failed, trying again...");            getAccessToken(callback);        });        req.write("grant_type=refresh_token&refresh_token=" + config.REFRESH_TOKEN + "&client_id=" + config.CLIENT_ID + "&client_secret=" + config.CLIENT_SECRET);        req.end();    }}function callAlexa(access_token, audio_file, callback) {    if(config.DEBUG) console.log("Calling AVS endpoint...");    var options = {        method: "POST",        hostname: "avs-alexa-na.amazon.com",        path: "/v20160207/events",        port: 443,        headers: {            "content-type": "multipart/form-data; boundary=---011000010111000001101001",            "authorization": "Bearer " + access_token,            "cache-control": "no-cache"        },        agent: new http.Agent({ keepAlive: false })  // turn off keep alive to avoid EOF errors    };    var req = http.request(options, function (res) {        if(res.statusCode != 200) {            if (config.DEBUG) console.log("Got a non-200 AVS response statusCode: " + res.statusCode);            var chunks = [];            res.on("data", function (chunk) {                chunks.push(chunk);            });            res.on("end", function () {                console.log(Buffer.concat(chunks).toString());                callback(null, null, false);            });        } else {            var chunks = [];            var boundary = res.headers["content-type"].substring(res.headers["content-type"].indexOf("boundary=") + 9);            boundary = '--' + boundary.substring(0, boundary.indexOf(';')) + '\r\n';            res.on("data", function (chunk) {                chunks.push(chunk);            });            res.on("error", function (err) {                if (config.DEBUG) console.log("AVS response failed, trying again...");                callback(err);                //callAlexa(access_token, audio_file, callback);            });            res.on("end", function () {                var body = Buffer.concat(chunks);                var parts_binary = bsplit(body, new Buffer(boundary));                var parts_strings = body.toString().split(boundary);                if(config.DEBUG) console.log("Using multipart boundary: " + boundary);                var parts = [];                var is_dialog = false;                // iterate through the parts designated by boundaries, skipping the first one which is always empty                for(var i = 1; i < parts_strings.length; i++) {                    var pieces = parts_strings[i].split('\r\n\r\n');                    var pieces_binary = bsplit(parts_binary[i], new Buffer('\r\n\r\n'));                    // grab the content type string                    if (pieces[0].indexOf('application/json') >= 0) {                        if(config.DEBUG) console.log("---\nReceived JSON: " + parts_strings[i] + "\n-------");                        parts.push({                            directiveName: JSON.parse(pieces[1]).directive.header.name,                            contentType: "application/json",                            content: JSON.parse(pieces[1])                        });                        if(JSON.parse(pieces[1]).directive.header.name == "ExpectSpeech") {                            is_dialog = true;                        }                    } else if (pieces[0].indexOf('octet') >= 0) {                        if(config.DEBUG) console.log("---\nReceived octet stream with length: " + pieces_binary[1].length);                        parts.push({                            directiveName: null,                            contentType: "application/octet-stream",                            content: pieces_binary[1]                        });                    } else {                        if(config.DEBUG) console.log("---\nReceived something else: " + parts_strings[i] + "\n-------");                    }                }                if(config.DEBUG) console.log("---\nFinished processing and found " + parts.length + " parts");                try {                    if (parts[0].content.directive.header.name == 'Speak') {                        if(config.DEBUG) console.log("Handling Speak event type");                        if(is_dialog) {                            callback(null, parts[2].content, is_dialog);                        } else {                            callback(null, parts[1].content, is_dialog);                        }                    } else if (parts[0].content.directive.header.name == 'Play') {                        if(config.DEBUG) console.log("Handling Audio playback event type");                        if(is_dialog) {                            callback(null, parts[2].content, is_dialog);                        } else {                            callback(null, parts[1].content, is_dialog);                        }                    } else {                        if(config.DEBUG) console.log("Unexpected event type: " + JSON.stringify(parts[0], 0, 4));                        callback(null, null, is_dialog);                    }                } catch (err) {                    if(config.DEBUG) console.log("Caught an error: " + err.stack);                }            });        }    });    req.write("-----011000010111000001101001\r\n");    req.write("Content-Disposition: form-data; name=\"metadata\"\r\n");    req.write("Content-Type: application/json; charset=UTF-8\r\n\r\n");    req.write('{"event":{"header":{"namespace":"SpeechRecognizer","name":"Recognize","messageId":"' + process.hrtime() + '","dialogRequestId":"' + process.hrtime() + '"},"payload":{"profile":"CLOSE_TALK","format":"AUDIO_L16_RATE_16000_CHANNELS_1"}}}' + "\r\n\r\n");    req.write("-----011000010111000001101001\r\n");    req.write("Content-Disposition: form-data; name=\"audio\"\r\n");    req.write("Content-Type: application/octet-stream\r\n\r\n");    var upload = fs.createReadStream(audio_file, {encoding: null});    upload.pipe(req, { end: false });    var bytes = 0;    upload.on('data', function(chunk) {       bytes += chunk.length;    });    upload.on('end', function() {        if(config.DEBUG) console.log("wrote " + bytes + " bytes")        req.write("-----011000010111000001101001--\r\n");        req.on("error", function (err) {            if (config.DEBUG) console.log("AVS request failed, trying again...");            callAlexa(access_token, audio_file, callback);        });        req.end();    });}